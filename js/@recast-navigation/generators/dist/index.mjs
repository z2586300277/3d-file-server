import{vec3 as e,recastConfigDefaults as t,Raw as i,RecastBuildContext as a,NavMesh as l,VerticesArray as r,TrianglesArray as s,createRcConfig as o,calcGridSize as n,allocHeightfield as h,createHeightfield as d,TriangleAreasArray as c,markWalkableTriangles as m,rasterizeTriangles as g,filterLowHangingWalkableObstacles as b,filterLedgeSpans as u,filterWalkableLowHeightSpans as f,allocCompactHeightfield as w,buildCompactHeightfield as S,freeHeightfield as y,erodeWalkableArea as p,buildDistanceField as M,buildRegions as R,allocContourSet as C,buildContours as x,Recast as k,allocPolyMesh as v,buildPolyMesh as z,allocPolyMeshDetail as _,buildPolyMeshDetail as A,freeCompactHeightfield as T,freeContourSet as E,NavMeshCreateParams as H,createNavMeshData as D,freePolyMesh as L,freePolyMeshDetail as P,TileCacheMeshProcess as F,TileCache as O,DetourTileCacheParams as I,NavMeshParams as $,RecastChunkyTriMesh as G,statusFailed as N,freeHeightfieldLayerSet as W,cloneRcConfig as B,ChunkIdsArray as j,allocHeightfieldLayerSet as K,buildHeightfieldLayers as V,TileCacheData as X,Detour as Y,getHeightfieldLayerHeights as U,getHeightfieldLayerAreas as Z,getHeightfieldLayerCons as q,buildTileCacheLayer as J,statusToReadableString as Q}from"@recast-navigation/core";const ee=(t,i)=>{const a={x:1/0,y:1/0,z:1/0},l={x:-1/0,y:-1/0,z:-1/0};for(let e=0;e<i.length;e++){const r=i[e],s=t[3*r],o=t[3*r+1],n=t[3*r+2];a.x=Math.min(a.x,s),a.y=Math.min(a.y,o),a.z=Math.min(a.z,n),l.x=Math.max(l.x,s),l.y=Math.max(l.y,o),l.z=Math.max(l.z,n)}return{bbMin:e.toArray(a),bbMax:e.toArray(l)}},te=e=>{let t=0,i=0;return t=Number(e>65535)<<4,e>>=t,i=Number(e>255)<<3,e>>=i,t|=i,i=Number(e>15)<<2,e>>=i,t|=i,i=Number(e>3)<<1,t|=i,t|=(e>>=i)>>1,t},ie=e=>(e--,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,++e),ae={...t},le=(e,t,F={},O=!1)=>{if(!i.Module)throw new Error('"init" must be called before using any recast-navigation-js APIs. See: https://github.com/isaac-mason/recast-navigation-js?tab=readme-ov-file#initialization');const I=new a,$={type:"solo",buildContext:I},G=new l,N=e=>(O||($.heightfield&&(y($.heightfield),$.heightfield=void 0),$.compactHeightfield&&(T($.compactHeightfield),$.compactHeightfield=void 0),$.contourSet&&(E($.contourSet),$.contourSet=void 0),$.polyMesh&&(L($.polyMesh),$.polyMesh=void 0),$.polyMeshDetail&&(P($.polyMeshDetail),$.polyMeshDetail=void 0)),G.destroy(),{navMesh:void 0,success:!1,intermediates:$,error:e}),W=e,B=t.length,j=new r;j.copy(W);const K=t,V=t.length/3,X=new s;X.copy(K);const{bbMin:Y,bbMax:U}=ee(e,t),Z=o({...ae,...F});Z.minRegionArea=Z.minRegionArea*Z.minRegionArea,Z.mergeRegionArea=Z.mergeRegionArea*Z.mergeRegionArea,Z.detailSampleDist=Z.detailSampleDist<.9?0:Z.cs*Z.detailSampleDist,Z.detailSampleMaxError=Z.ch*Z.detailSampleMaxError;const q=n(Y,U,Z.cs);Z.width=q.width,Z.height=q.height;const J=h();if($.heightfield=J,!d(I,J,Z.width,Z.height,Y,U,Z.cs,Z.ch))return N("Could not create heightfield");const Q=new c;if(Q.resize(V),m(I,Z.walkableSlopeAngle,j,B,X,V,Q),!g(I,j,B,X,Q,V,J,Z.walkableClimb))return N("Could not rasterize triangles");Q.destroy(),j.destroy(),X.destroy(),b(I,Z.walkableClimb,J),u(I,Z.walkableHeight,Z.walkableClimb,J),f(I,Z.walkableHeight,J);const te=w();if($.compactHeightfield=te,!S(I,Z.walkableHeight,Z.walkableClimb,J,te))return N("Failed to build compact data");if(O||(y(J),$.heightfield=void 0),!p(I,Z.walkableRadius,te))return N("Failed to erode walkable area");if(!M(I,te))return N("Failed to build distance field");if(!R(I,te,Z.borderSize,Z.minRegionArea,Z.mergeRegionArea))return N("Failed to build regions");const ie=C();if($.contourSet=ie,!x(I,te,Z.maxSimplificationError,Z.maxEdgeLen,ie,k.RC_CONTOUR_TESS_WALL_EDGES))return N("Failed to create contours");const le=v();if($.polyMesh=le,!z(I,ie,Z.maxVertsPerPoly,le))return N("Failed to triangulate contours");const re=_();if($.polyMeshDetail=re,!A(I,le,te,Z.detailSampleDist,Z.detailSampleMaxError,re))return N("Failed to build detail mesh");O||(T(te),$.compactHeightfield=void 0,E(ie),$.contourSet=void 0);for(let e=0;e<le.npolys();e++)le.areas(e)==k.RC_WALKABLE_AREA&&le.setAreas(e,0),0==le.areas(e)&&le.setFlags(e,1);const se=new H;se.setPolyMeshCreateParams(le),se.setPolyMeshDetailCreateParams(re),se.setWalkableHeight(Z.walkableHeight),se.setWalkableRadius(Z.walkableRadius),se.setWalkableClimb(Z.walkableClimb),se.setCellSize(Z.cs),se.setCellHeight(Z.ch),se.setBuildBvTree(!0),F.offMeshConnections&&se.setOffMeshConnections(F.offMeshConnections);const oe=D(se);if(!oe.success)return N("Failed to create Detour navmesh data");const{navMeshData:ne}=oe;return G.initSolo(ne)?{success:!0,navMesh:G,intermediates:$}:N("Failed to create Detour navmesh")},re={...t,tileSize:32,expectedLayersPerTile:4,maxObstacles:128},se=()=>new F(((e,t,i)=>{for(let a=0;a<e.polyCount();++a)t.set(a,0),i.set(a,1)})),oe=(t,M,R={},C=!1)=>{if(!i.Module)throw new Error('"init" must be called before using any recast-navigation-js APIs. See: https://github.com/isaac-mason/recast-navigation-js?tab=readme-ov-file#initialization');const x=new a,v={type:"tilecache",buildContext:x,chunkyTriMesh:void 0,tileIntermediates:[]},z=new O,_=new l,A=t,E=M.length,H=new r;H.copy(A);const D=M,L=M.length/3,P=new s;P.copy(D);const{bbMin:F,bbMax:Q}=ee(t,M),{expectedLayersPerTile:ae,maxObstacles:le,...oe}={...re,...R},ne=()=>{if(H.destroy(),P.destroy(),!C)for(let e=0;e<v.tileIntermediates.length;e++){const t=v.tileIntermediates[e];t.heightfield&&(y(t.heightfield),t.heightfield=void 0),t.compactHeightfield&&(T(t.compactHeightfield),t.compactHeightfield=void 0),t.heightfieldLayerSet&&(W(t.heightfieldLayerSet),t.heightfieldLayerSet=void 0)}},he=e=>(ne(),z.destroy(),_.destroy(),{success:!1,navMesh:void 0,tileCache:void 0,intermediates:v,error:e}),de=o(oe),ce=n(F,Q,de.cs);de.width=ce.width,de.height=ce.height,de.minRegionArea=de.minRegionArea*de.minRegionArea,de.mergeRegionArea=de.mergeRegionArea*de.mergeRegionArea,de.detailSampleDist=de.detailSampleDist<.9?0:de.cs*de.detailSampleDist,de.detailSampleMaxError=de.ch*de.detailSampleMaxError;const me=Math.floor(de.tileSize),ge=Math.floor((de.width+me-1)/me),be=Math.floor((de.height+me-1)/me);de.borderSize=de.walkableRadius+3,de.width=de.tileSize+2*de.borderSize,de.height=de.tileSize+2*de.borderSize;const ue=I.create({orig:F,cs:de.cs,ch:de.ch,width:de.tileSize,height:de.tileSize,walkableHeight:de.walkableHeight,walkableRadius:de.walkableRadius,walkableClimb:de.walkableClimb,maxSimplificationError:de.maxSimplificationError,maxTiles:ge*be*ae,maxObstacles:le}),fe=new i.RecastLinearAllocator(32e3),we=new i.RecastFastLZCompressor,Se=R.tileCacheMeshProcess??se();if(!z.init(ue,fe,we,Se))return he("Failed to initialize tile cache");const ye=e.fromArray(F);let pe=Math.min(Math.floor(te(ie(ge*be*ae))),14);pe>14&&(pe=14);const Me=1<<pe,Re=1<<22-pe,Ce=$.create({orig:ye,tileWidth:de.tileSize*de.cs,tileHeight:de.tileSize*de.cs,maxTiles:Me,maxPolys:Re});if(!_.initTiled(Ce))return he("Failed to initialize tiled navmesh");const xe=new G;if(v.chunkyTriMesh=xe,!xe.init(H,P,L,256))return he("Failed to build chunky triangle mesh");const ke=(e,t)=>{const a={tileX:e,tileY:t},l=de.tileSize*de.cs,r=B(de),s=[F[0]+e*l,F[1],F[2]+t*l],o=[F[0]+(e+1)*l,Q[1],F[2]+(t+1)*l];s[0]-=r.borderSize*r.cs,s[2]-=r.borderSize*r.cs,o[0]+=r.borderSize*r.cs,o[2]+=r.borderSize*r.cs,r.set_bmin(0,s[0]),r.set_bmin(1,s[1]),r.set_bmin(2,s[2]),r.set_bmax(0,o[0]),r.set_bmax(1,o[1]),r.set_bmax(2,o[2]);const n=h();if(a.heightfield=n,!d(x,n,r.width,r.height,s,o,r.cs,r.ch))return{n:0};const M=[s[0],s[2]],R=[o[0],o[2]],k=new j;k.resize(512);const z=xe.getChunksOverlappingRect(M,R,k,512);if(0===z)return{n:0};for(let e=0;e<z;++e){const t=k.get(e),i=xe.nodes(t).n,a=xe.getNodeTris(t),l=new c;l.resize(i),m(x,r.walkableSlopeAngle,H,E,a,i,l);const s=g(x,H,E,a,l,i,n,r.walkableClimb);if(l.destroy(),!s)return{n:0}}b(x,de.walkableClimb,n),u(x,de.walkableHeight,de.walkableClimb,n),f(x,de.walkableHeight,n);const _=w();if(!S(x,de.walkableHeight,de.walkableClimb,n,_))return{n:0};if(C||(y(a.heightfield),a.heightfield=void 0),!p(x,de.walkableRadius,_))return{n:0};const A=K();if(!V(x,_,de.borderSize,de.walkableHeight,A))return{n:0};C||(T(_),a.compactHeightfield=void 0);const D=[];for(let a=0;a<A.nlayers();a++){const l=new X,r=A.layers(a),s=new i.dtTileCacheLayerHeader;s.magic=Y.DT_TILECACHE_MAGIC,s.version=Y.DT_TILECACHE_VERSION,s.tx=e,s.ty=t,s.tlayer=a;const o=r.bmin(),n=r.bmax();s.set_bmin(0,o.x),s.set_bmin(1,o.y),s.set_bmin(2,o.z),s.set_bmax(0,n.x),s.set_bmax(1,n.y),s.set_bmax(2,n.z),s.width=r.width(),s.height=r.height(),s.minx=r.minx(),s.maxx=r.maxx(),s.miny=r.miny(),s.maxy=r.maxy(),s.hmin=r.hmin(),s.hmax=r.hmax();const h=U(r),d=Z(r),c=q(r),m=J(we,s,h,d,c,l);if(N(m))return{n:0};D.push(l)}return C||(W(A),a.heightfieldLayerSet=void 0),v.tileIntermediates.push(a),{n:D.length,tiles:D}};for(let e=0;e<be;++e)for(let t=0;t<ge;++t){const{n:i,tiles:a}=ke(t,e);if(i>0&&a)for(let l=0;l<i;l++){const i=a[l],r=z.addTile(i);N(r.status)&&x.log(k.RC_LOG_WARNING,`Failed to add tile to tile cache - tx: ${t}, ty: ${e}`)}}for(let e=0;e<be;e++)for(let t=0;t<ge;t++){const i=z.buildNavMeshTilesAt(t,e,_);if(N(i))return he(`Failed to build nav mesh tiles at ${t}, ${e}`)}return ne(),{success:!0,tileCache:z,navMesh:_,intermediates:v}},ne={...t},he=(t,F,O={},I=!1)=>{if(!i.Module)throw new Error('"init" must be called before using any recast-navigation-js APIs. See: https://github.com/isaac-mason/recast-navigation-js?tab=readme-ov-file#initialization');const W=new a,K={type:"tiled",buildContext:W,chunkyTriMesh:void 0,tileIntermediates:[]},V=new l,X=t,U=F.length,Z=new r;Z.copy(X);const q=F,J=F.length/3,ae=new s;ae.copy(q);const le=()=>{if(Z.destroy(),ae.destroy(),!I){for(let e=0;e<K.tileIntermediates.length;e++){const t=K.tileIntermediates[e];t.compactHeightfield&&T(t.compactHeightfield),t.heightfield&&y(t.heightfield),t.contourSet&&E(t.contourSet),t.polyMesh&&L(t.polyMesh),t.polyMeshDetail&&P(t.polyMeshDetail)}K.chunkyTriMesh&&(K.chunkyTriMesh=void 0)}},re=e=>(le(),V.destroy(),{success:!1,navMesh:void 0,intermediates:K,error:e}),se=o({...ne,...O}),{bbMin:oe,bbMax:he}=ee(t,F),de=n(oe,he,se.cs);se.width=de.width,se.height=de.height,se.minRegionArea=se.minRegionArea*se.minRegionArea,se.mergeRegionArea=se.mergeRegionArea*se.mergeRegionArea,se.tileSize=Math.floor(se.tileSize),se.borderSize=se.walkableRadius+3,se.width=se.tileSize+2*se.borderSize,se.height=se.tileSize+2*se.borderSize,se.detailSampleDist=se.detailSampleDist<.9?0:se.cs*se.detailSampleDist,se.detailSampleMaxError=se.ch*se.detailSampleMaxError;const ce=Math.floor(se.tileSize),me=Math.floor((de.width+ce-1)/ce),ge=Math.floor((de.height+ce-1)/ce),be=se.tileSize*se.cs,ue=e.fromArray(oe);let fe=Math.min(Math.floor(te(ie(me*ge))),14);fe>14&&(fe=14);const we=1<<fe,Se=1<<22-fe,ye=$.create({orig:ue,tileWidth:se.tileSize*se.cs,tileHeight:se.tileSize*se.cs,maxTiles:we,maxPolys:Se});if(!V.initTiled(ye))return re("Could not init nav mesh for tiled use");const pe=new G;if(K.chunkyTriMesh=pe,!pe.init(Z,ae,J,256))return re("Failed to build chunky triangle mesh");const Me=(e,t,i,a)=>{const l=e=>(W.log(k.RC_LOG_ERROR,e),{success:!1,error:e}),r={tileX:e,tileY:t};K.tileIntermediates.push(r);const s=B(se),o=[...i],n=[...a];o[0]-=s.borderSize*s.cs,o[2]-=s.borderSize*s.cs,n[0]+=s.borderSize*s.cs,n[2]+=s.borderSize*s.cs,s.set_bmin(0,o[0]),s.set_bmin(1,o[1]),s.set_bmin(2,o[2]),s.set_bmax(0,n[0]),s.set_bmax(1,n[1]),s.set_bmax(2,n[2]),W.resetTimers(),W.startTimer(k.RC_TIMER_TOTAL),W.log(k.RC_LOG_PROGRESS,`Building tile ${K.tileIntermediates.length} at x: ${e}, y: ${t}`),W.log(k.RC_LOG_PROGRESS,` - ${se.width} x ${se.height} cells`),W.log(k.RC_LOG_PROGRESS,` - ${U/1e3}fK verts, ${J/1e3}K tris`);const L=h();if(r.heightfield=L,!d(W,L,s.width,s.height,o,n,s.cs,s.ch))return l("Could not create heightfield");(new c).resize(pe.maxTrisPerChunk());const P=[o[0],o[2]],F=[n[0],n[2]],$=new j;$.resize(512);const G=pe.getChunksOverlappingRect(P,F,$,512);if(0===G)return{success:!0};for(let e=0;e<G;++e){const t=$.get(e),i=pe.nodes(t).n,a=pe.getNodeTris(t),r=new c;r.resize(i),m(W,s.walkableSlopeAngle,Z,U,a,i,r);const o=g(W,Z,U,a,r,i,L,s.walkableClimb);if(r.destroy(),!o)return l("Could not rasterize triangles")}b(W,s.walkableClimb,L),u(W,s.walkableHeight,s.walkableClimb,L),f(W,s.walkableHeight,L);const N=w();if(r.compactHeightfield=N,!S(W,s.walkableHeight,s.walkableClimb,L,N))return l("Could not build compact heightfield");if(I||(y(r.heightfield),r.heightfield=void 0),!p(W,s.walkableRadius,N))return l("Could not erode walkable area");if(!M(W,N))return l("Failed to build distance field");if(!R(W,N,s.borderSize,s.minRegionArea,s.mergeRegionArea))return l("Failed to build regions");const V=C();if(r.contourSet=V,!x(W,N,s.maxSimplificationError,s.maxEdgeLen,V,k.RC_CONTOUR_TESS_WALL_EDGES))return l("Failed to create contours");const X=v();if(r.polyMesh=X,!z(W,V,s.maxVertsPerPoly,X))return l("Failed to triangulate contours");const Y=_();if(r.polyMeshDetail=Y,!A(W,X,N,s.detailSampleDist,s.detailSampleMaxError,Y))return l("Failed to build detail mesh");I||(T(N),r.compactHeightfield=void 0,E(V),r.contourSet=void 0);for(let e=0;e<X.npolys();e++)X.areas(e)==k.RC_WALKABLE_AREA&&X.setAreas(e,0),0==X.areas(e)&&X.setFlags(e,1);const q=new H;q.setPolyMeshCreateParams(X),q.setPolyMeshDetailCreateParams(Y),q.setWalkableHeight(s.walkableHeight),q.setWalkableRadius(s.walkableRadius),q.setWalkableClimb(s.walkableClimb),q.setCellSize(s.cs),q.setCellHeight(s.ch),q.setBuildBvTree(!0),O.offMeshConnections&&q.setOffMeshConnections(O.offMeshConnections),q.setTileX(e),q.setTileY(t);const Q=D(q);return Q.success?(W.log(k.RC_LOG_PROGRESS,`>> Polymesh: ${X.nverts()} vertices  ${X.npolys()} polygons`),{success:!0,data:Q.navMeshData}):l("Failed to create Detour navmesh data")};W.startTimer(k.RC_TIMER_TEMP);const Re=[0,0,0],Ce=[0,0,0];for(let e=0;e<ge;e++)for(let t=0;t<me;t++){Re[0]=oe[0]+t*be,Re[1]=oe[1],Re[2]=oe[2]+e*be,Ce[0]=oe[0]+(t+1)*be,Ce[1]=he[1],Ce[2]=oe[2]+(e+1)*be;const i=Me(t,e,Re,Ce);if(i.success&&i.data){V.removeTile(V.getTileRefAt(t,e,0));const a=V.addTile(i.data,Y.DT_TILE_FREE_DATA,0);N(a.status)&&(W.log(k.RC_LOG_WARNING,`Failed to add tile to nav mesh\n\ttx: ${t}, ty: ${e},status: ${Q(a.status)} (${a.status})`),i.data.destroy())}}return W.stopTimer(k.RC_TIMER_TEMP),I||le(),{success:!0,navMesh:V,intermediates:K}};export{se as createDefaultTileCacheMeshProcess,te as dtIlog2,ie as dtNextPow2,le as generateSoloNavMesh,oe as generateTileCache,he as generateTiledNavMesh,ee as getBoundingBox,ae as soloNavMeshGeneratorConfigDefaults,re as tileCacheGeneratorConfigDefaults,ne as tiledNavMeshGeneratorConfigDefaults};
//# sourceMappingURL=index.mjs.map
